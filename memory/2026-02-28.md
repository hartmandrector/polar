# 2026-02-28 — Session Notes

## BASElineXR Sensor Visualization — Rotation Pipeline

- **RawSensorVisualizationSystem.kt** draws the FlySight device model + accel/mag arrows using on-device fusion quaternion
- **SensorMath.kt** has clean NWU→Meta conversion: `quaternionNwuToMeta(-y, z, -x, w)` and `nwuToMeta(-y, z, -x)` for vectors
- **BUT** the actual visualization uses a DIFFERENT empirical quaternion: `(-qx, qz, qy, qw)` — doesn't match theoretical conversion
- The empirical mapping absorbs the GLB model's authoring orientation (sensor_device.glb was flipped upside down to fix identity pose)
- Vector arrow GLBs needed separate forward-axis negation to work with the same quaternion
- **Core issue**: coordinate corrections split across GLB model orientation AND math code — makes reasoning difficult
- Hartman manually iterated on GLB edits + axis swaps/negates to get device rotations matching in all 3 axes
- Vectors are close but X/Z not fully correct yet — more axis flipping needed

## Firmware Fusion — Algorithm Frame Discovery

- **Sensor fusion handoff project** at `/mnt/c/dev/flysight firmware/sensor_fusion_handoff/`
- **FusionAhrsAdapter.ts** defines the full coordinate pipeline:
  - FlySight body frame: X=West, Y=Up (LED), Z=North (front face)
  - NWU algorithm frame: X=North, Y=West, Z=Up
  - `bodyToNWU(bx, by, bz) = (bz, bx, by)` — simple axis cycle
  - Inverse: `nwuToBody(nx, ny, nz) = (ny, nz, nx)`
- **Key question raised**: Does the firmware do the body→NWU remap before feeding the fusion algorithm? If raw sensor axes go straight into Madgwick/Fusion without the `(bz, bx, by)` remap, the output quaternion is in a rotated frame, forcing every downstream consumer to compensate
- **Cleanest fix**: Do body→NWU remap in firmware pre-fusion, so quaternion output is always true NWU. Then BASElineXR only needs one NWU→Meta conversion.

## GPS Flight Computer Doc

- Created `GPS-FLIGHT-COMPUTER.md` in FlySight firmware Docs/ folder
- Committed on `upstream-merge` branch, pushed to origin (`55e8729` area)
- Covers: dynModel table, flight phase configs, proposed control point commands, UBX message catalog, BLE bandwidth budget
- Additional high-value UBX messages identified: NAV-DOP (for Kalman filter weighting), NAV-STATUS (spoofing/integrity), MON-HW (jamming), CFG-RXM (power management), CFG-RST (hot restart)

## Open Questions (Firmware)

- Best BLE queue protection divider algorithm (default 1 vs 0)
- Whether to keep sensor fusion on-device or strip to sensors-only branch
- On-device mag cal (ST Micro libs) vs BLE-commanded client-side cal
- Gain/rejection settings integration with flight computer
- Possible new firmware branch: sensors-only (no fusion, no fusion control points)

## BASElineXR Direction

- Becoming a "sensor data integration hub" — real-time data collection, calibration, dual fusion comparison
- Two fusion viewers side by side: on-device (firmware Madgwick) vs client-side (BASElineXR AHRS)
- Mag calibration system needs live data buffer (currently only saved tracks)
- Planned: 10-second "capture calibration" mode, orthogonal sample selection, send cal to FlySight or apply client-side
- Mode switching between saved track playback and live sensor data

## Mag Calibration Reference Frame Analysis (afternoon session)

### BLE→Firmware Control Point Path — CONFIRMED WORKING
- `Flysight2ControlPoint.java`: `setMagHardIron(x,y,z)` → gauss→milligauss → 6-byte payload (3× int16 LE) with cmd `0x20`
- `sensor_data.c`: parses `SD_CMD_SET_FUSION_MAG_HARD` → milligauss→gauss → `FS_Fusion_SetMagHardIron(FusionVector)`
- `fusion_integration.c`: `FS_Fusion_SetMagHardIron()` writes directly to `mag_hard_iron` static var — immediate effect on next sample
- Path is clean, units match, format correct

### Calibration Lifecycle on Firmware
- **Boot**: `FS_Fusion_Init()` loads from `config.txt` on SD card. Defaults: hard iron = (0,0,0), soft iron = identity
- **Config file**: Supports `Fusion_Mag_Hard_X/Y/Z` (milligauss integers), `Fusion_Mag_Soft_M0-M8`
- **BLE override**: Writes to RAM only, takes effect immediately
- **Mode transition (sleep→active)**: `FS_Fusion_Init()` called again → reloads from config.txt, **wipes BLE-sent calibration**
- **No persistence of BLE calibrations** — must re-send after every reconnect/mode change
- Hartman's assessment: lifecycle is fine — in-airplane calibration for flight is the use case, static config for post-processing

### Sensor Fusion Project Calibration Bug FOUND
- `magCalibration.ts` in sensor_fusion_handoff applies axis transform BEFORE computing calibration:
  ```typescript
  if (applyAxisTransform) { return { x: -s.x, y: s.y, z: -s.z }; }
  ```
- This means saved calibrations are in **device body frame** (after LIS2MDL -X,+Y,-Z remap)
- Firmware expects calibration in **sensor frame** (applies cal first, then remaps)
- BASElineXR calibrator works on raw BLE data = sensor frame ✅
- **Sensor fusion project calibrations have X and Z offsets with wrong signs** if sent to firmware
- Fix: negate X and Z, or use `applyAxisTransform: false`

### Quaternion Mapping Analysis — RawSensorVisualizationSystem.kt line 152
- Working empirical: `Quaternion(-imu.qx, imu.qz, imu.qy, imu.qw)`
- Comment says "Cycle axes: X=Y, Y=Z, Z=X" — WRONG, actual is `(-x, z, y, w)`
- Theoretical device→Meta mapping: `(qx, qz, -qy, qw)` based on:
  - Device body: X=East, Y=North(LED), Z=Up
  - Meta: X=East, Y=Up, Z=South
- Difference between theoretical and empirical = 180° rotation around Y(up) axis
- Absorbed by GLB model (sensor_device.glb) being authored facing opposite direction
- Created `quaternionDeviceToMeta()` in SensorMath.kt but Hartman reverted — visual result was different (needs investigation)
- **Reverted to original inline formula** — Hartman wants to test with current setup first

### restorewindfilter Branch — Head Model System
- `HeadModelSystem.kt` (~190 lines) — draws `fullheadneck.gltf` at pilot's head position
- GLB assets: `fullheadneck.gltf`, `fullhead.gltf`, `headposition.gltf` (head+helmet+FlySight combo)
- Uses `QuaternionUtil.kt` for GPS attitude→Meta conversion, `modelOffset180()`, euler helpers
- `updateFromWingsuit()` receives flight attitude + position from WingsuitCanopySystem
- HMD rotation (`headPose.q`) drives head model directly — key reference for GLB→Meta mapping
- **Plan**: Port GLB file + minimal head rotation to sensor-ble branch for side-by-side quaternion comparison
- Recommendation: Don't port full HeadModelSystem (flight positioning dependency not needed); just grab GLB + add head entity to RawSensorVisualizationSystem
